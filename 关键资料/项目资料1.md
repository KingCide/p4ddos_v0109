下面我把**研究点 1（基于在网计算/可编程交换机的 LEO 卫星网络 LFA（Link Flooding Attack）实时检测与缓解）**进一步细化成“论文一章”的写法：**问题模型 → 关键观察/设计目标 → 结构设计 → 算法/公式 → 仿真实现 → 实验矩阵**。我会以 SatShield 为“基线工作”，并明确你还能往前推进的点（尤其是它自己也点出的局限：仅靠速率特征在 bot 规模增大时会变弱，需要加入 fan-in/out 等签名）。

---

## 1 研究问题与目标定义

### 1.1 为什么是 LEO 场景的“在网计算”

SatShield 直接指出：LEO 星座网络的**星地/星间链路控制与反馈延迟可达几十毫秒**，但攻击流量可以在**亚毫秒**尺度动态调整，导致“控制面收集—分析—下发”的闭环反应慢，难以应对。
因此你的研究点 1 的核心就是：**把“检测+缓解”尽可能下沉到卫星数据平面（可编程交换机）**，形成“线速、局部、快速”的防御闭环。

### 1.2 系统目标（写进论文的优化目标/约束）

给出三个可量化目标（后面实验指标直接对应）：

* **G1：快速反应**：从“第一批攻击包出现”到“开始产生抑制效果”的时间最小（reaction time）。SatShield 定义了 reaction time：从收到首个攻击包到开始缓解的时长。
* **G2：保护良性吞吐**：攻击期间良性业务吞吐下降最小（throughput drop 最小）。
* **G3：可实现性**：数据平面资源受限（片上存储/流水线 stage），避免“记录所有流”的不可扩展方案。SatShield 论证了 sketch+阻断的内存、不可逆、控制环延迟等问题。

---

## 2 问题模型（建议直接作为“第 3 章：系统模型与威胁模型”）

### 2.1 LEO 网络与业务模型（时变图）

用时变图表示星座：

* 在时刻 (t)，网络为 (G(t)=(V(t),E(t)))，其中 (V(t)) 为卫星节点集合，(E(t)) 为 ISL/星间链路集合（拓扑秒级变化是 LEO 特性）。
* 每条链路 (e\in E(t)) 有容量 (C_e(t))，链路负载为 (\lambda_e(t))，利用率：
  [
  u_e(t)=\frac{\lambda_e(t)}{C_e(t)}
  ]
* 每条“端到端连接”（城市对/地面区域对）在星座中会映射为随 (t) 变化的路径 (\pi_{sd}(t))。

**参数建议直接对齐 SatShield 的仿真设定**（你复现实验会很顺）：Starlink Shell 1（1584 颗卫星）、ISL 20Gb/s、终端上行 64Mb/s、下行 384Mb/s、单星最多服务 2080 用户等。L371-L389

### 2.2 LFA 攻击模型（目标链路洪泛）

LFA 的核心不是“打某个服务器”，而是**让某条/某组关键链路拥塞**，从而切断特定区域间通信。SatShield 描述了攻击者可利用公开轨道信息预测路径与目标链路，并在全球招募 bot 发起洪泛。

定义：

* 目标链路集合 (E^*\subseteq E(t))（可能随时间漂移）。
* 攻击者控制 bot 集合 (B)，构造到“诱饵/目标”端点集合 (D) 的流集合 (\mathcal{F}*A(t))，使得对某条目标链路 (e^*)：
  [
  \lambda*{e^*}(t)=\lambda_{e^*}^{benign}(t)+\lambda_{e^*}^{attack}(t)\ge C_{e^*}(t)
  ]

**LEO 场景的重要约束**（也是“为什么能检测到”的关键来源）：

* bot 规模并非无限，受系统服务能力约束；SatShield 以 10000 终端（约 1% 用户）为例分析攻击流速仍显著高于互联网流速分位。
* 攻击者可以用五元组拆分把“每条 5-tuple 流”的速率压到很低（几十 Kb/s），但**按源/目的地址聚合**时，总速率依然保持；且这种策略会显著提升 fan-out。

---

## 3 关键观察与设计假设（写成“第 4 章：动机与设计原则”）

### 3.1 可检测特征：聚合速率分布异常

SatShield 的核心观察：由于 bot 规模受限，攻击聚合流速（按 src 或 dst 地址聚合）与良性流速分布显著不同——“bot 往往是 Mb/s 级，而 99% 良性低于 400Kb/s”。

### 3.2 为什么不能用“全量 sketch + 阻断”

SatShield 逐条给了反例（你论文可以直接借其逻辑链）：

* 高流量链路上流数“百万级/秒”，要保证精度需要很大内存；小内存则碰撞严重。
* sketch 不可逆，难以直接定位具体恶意流；可逆 sketch 又要额外数组+复杂关联。
* 简单阻断可能误伤高吞吐良性流。
* 还要依赖控制器算速率并下发规则，LEO 控制环延迟使其在亚秒级变化攻击下失效。

---

## 4 结构设计（你的“系统方案章节”可以按这个写）

我建议你把研究点 1 做成：**“SatShield 基线 + 你的改进（多签名/自适应阈值/更强对抗）”**。因为 SatShield 自己也承认：未来要加 fan-in/out 等新签名来对抗 bot 规模增大带来的“速率特征退化”。

### 4.1 总体架构（数据平面为主、轻量控制面）

沿用 SatShield 的两大模块划分（非常清晰、论文好写）：

1. **Flow Detector（数据平面）**：线速维护 top-k heavy flows。
2. **Flow Scheduler（队列/调度缓解）**：在拥塞时对“更可疑的流”降低优先级，**被动丢弃**，尽量不误伤良性。

并保留“星上 agent（轻量控制面）”按 epoch 导出 top-k 结果、配置队列优先级映射：SatShield 的 heavy flow 在 epoch 末导出，阈值 (\tau) 用于判定。

> 你做“仿真”时，agent 可以就是模拟器里的一个周期任务；不用真上 Tofino。

### 4.2 Flow Detector：Top-k filter + Auxiliary（可直接复刻）

SatShield 的 detector 数据结构非常适合写成论文“结构设计”：

* (d) 级 hash table（通常 (d=8)），每级 (m) 个 bucket，记录 (key,cnt)。key 是 src 或 dst 地址，cnt 为字节计数。
* 辅助表（aux table）每 bucket 有 (Mkey,Rcnt,Vcnt)，借鉴 MJRTY majority vote，解决冲突并支持“promotion”。
* 通过 recirculation 把 aux 中变“更重”的记录送回 top-k（解决 HashPipe 类方法的记录碎片/误淘汰问题）。

其核心更新算法 SatShield 已给出 Algorithm 1（你可以在论文里直接“复现+说明”）。

### 4.3 你的改进点（建议作为本研究点 1 的“创新”）

**仅靠“聚合速率”会在以下情况变弱：**

* bot 规模增大（每个 bot 速率更低、更接近良性）；
* 某些真实业务本来就有大流（如大文件传输/视频上行），容易被当作 top-k heavy。
  SatShield 也明确提出需要引入 **fan-in / fan-out** 等新签名。

因此我建议你的研究点 1 的创新定义为：

> **MS-SatShield：多签名（Rate + Fan-out/Fan-in + 持续性）在网检测 + 分级队列缓解**
> 在 SatShield 的 top-k 框架上，只对“进入 top-k 的少量 key”做更深的签名统计，从而成本可控。

#### (A) 多签名可疑度建模（公式可直接写进论文）

对每个地址 key (a)（src 或 dst）在 epoch (\Delta) 内：

* 聚合速率：
  [
  R(a)=\frac{\text{bytes}(a)}{\Delta}
  ]
* fan-out（以源地址为例）：
  [
  FO(a)=\left|{dst \mid (a,dst)\in \mathcal{F}(\Delta)}\right|
  ]
  SatShield 已指出：五元组拆分会让 per-flow 速率很低，但会显著提高 fan-out，可用于检测。

定义一个可疑度分数（给你一个“可调权重、可做消融实验”的形式）：
[
S(a)=\alpha \cdot \text{norm}(R(a))+\beta \cdot \text{norm}(FO(a))+\gamma \cdot \text{persist}(a)
]

* (\text{norm}(\cdot)) 可用分位归一化（如除以 benign 的 (p99) 估计）；
* (\text{persist}(a)) 表示连续 (k_p) 个 epoch 都进入 top-k 的“持续性”（对抗脉冲/抖动与误报）。

> 关键点：**只对 top-k key 维护 FO/FI**，而不是对所有 key 维护，从而保持可实现性（你可以用“资源-精度权衡”作为小节写）。

#### (B) 分级队列缓解策略（比“直接阻断”更适合卫星）

SatShield 的缓解思想是“队列调度替代阻断”：top-k 更低优先级，在拥塞时被动丢弃，非拥塞时正常转发。

你可以把它形式化为：

* 设 egress 有 (Q) 个优先级队列（0 为最高优先级）；
* 映射函数（每个 epoch 更新一次）：
  [
  q(a)=\left\lfloor (Q-1)\cdot \sigma(S(a))\right\rfloor
  ]
  其中 (\sigma(\cdot)) 为 S 的压缩函数（如 sigmoid 或分位映射），保证极端可疑的 key 被映射到最低优先级。

**论文里强调“always-on”**：SatShield 认为即使常开，对良性流的乱序影响也不显著，可作为你系统默认工作方式的依据。

---

## 5 算法流程（可以直接画流程图 + 给伪代码）

### 5.1 数据平面每包处理（Detector）

复刻 SatShield Algorithm 1（top-k + aux + recirculate）。
你新增的部分：当 key 已在 top-k（或本包更新后进入 top-k）时，更新该 key 的 FO/FI 估计结构（仿真里可以用精确 set；写论文时说明硬件可用 bitmap/近似 distinct）。

### 5.2 epoch 任务（agent/控制逻辑）

SatShield 的 heavy flow 判定：epoch 末遍历 bucket，cnt≥(\tau) 则报告 heavy key。
你的扩展：

1. 取 heavy key 集合 (\mathcal{H})；
2. 对每个 (a\in\mathcal{H})，计算 (R(a), FO(a))，得到 (S(a))；
3. 更新队列映射 (q(a))；
4. 清空/衰减 FO 统计（进入下一 epoch）。

---

## 6 仿真与复现实验方案（你可以完全按 SatShield 的“LEO 攻击复现路径”走）

### 6.1 仿真平台与流量生成

SatShield 用 Icarus（专用于 LEO 星座攻击/防御仿真）+ Starlink Shell 1，并用 CAIDA19 + Pop 分布生成背景流量。
攻击与良性混合时仍保持“按 src/dst 聚合的攻击流速明显高于良性”的结论。

你可以照这个实现路径写成“实验设置”小节：

* 拓扑：1584 sats；ISL 20Gb/s；终端上/下行速率与单星用户数按表设定。file2L371-L389
* 背景：CAIDA19 抽样；按人口分布 city-to-city；控制初始链路利用率<90%。
* 攻击：选定 city pair（可用论文中的 Bangkok–Mexico 作为可复现实例），以及随机 20 对 city pair（泛化性）。

### 6.2 对比基线（论文必须有）

至少包含：

* No defense / FIFO；
* SatShield（rate-only top-k + queue）；
* Jaqen、ACC-Turbo（SatShield 在评估里明确拿它们对比，并解释 Jaqen 反应慢的原因：需连续两个窗口超过阈值才确认攻击，导致约 10s reaction time）。
* 你的 MS-SatShield（rate+fan-out+persist）。

---

## 7 实验矩阵（建议直接放论文“表 6-1/6-2”）

下面给你一个“够写一章、也够支撑创新点”的实验矩阵。你可以先做核心子集，后续再扩展。

| 维度              | 取值（建议）                                                                         | 目的                              |                   |              |
| --------------- | ------------------------------------------------------------------------------ | ------------------------------- | ----------------- | ------------ |
| 拓扑/规模           | Starlink Shell 1（1584 sats）固定；可选扩展 0.5×/2×规模                                   | 验证可扩展性                          |                   |              |
| ISL 容量 (C)      | 10/20/40 Gb/s                                                                  | 不同带宽下的拥塞阈值与误报                   |                   |              |
| 背景负载            | 3/5/10/15/19.5 Gb/s（仿 SatShield 的多负载场景思路）                                      | 观察保护良性能力                        |                   |              |
| bot 数量 (        | B                                                                              | )                               | 100/300/1k/5k/10k | 检验“速率特征退化”拐点 |
| 攻击策略            | (i) 朴素 LFA；(ii) 5-tuple 拆分降 per-flow 速率（会提高 fan-out）；(iii) 动态自适应目标链路/目标对（秒级变更） | 验证对抗性                           |                   |              |
| Detector key 选择 | src-only / dst-only / src+dst（并行 top-k）                                        | 适配不同攻击/诱饵布置                     |                   |              |
| epoch (\Delta)  | 50ms/100ms/500ms/1s/2s                                                         | 反应时间 vs 稳定性权衡（SatShield 约 1s 级） |                   |              |
| top-k 参数        | (k=) 1k/5k/10k/20k                                                             | 资源与精度权衡；写“敏感性分析”                |                   |              |
| 签名组合            | rate-only（SatShield） vs rate+fan-out vs rate+fan-out+persist                   | 你的核心贡献消融                        |                   |              |
| 缓解策略            | block（ straw-man ）vs 队列降权/被动丢弃（SatShield）                                      | 证明为何队列更适合 LEO                   |                   |              |

### 指标（检测 + 缓解必须都给）

检测侧（可直接引用 SatShield 的定义写法）：

* Precision / Recall / F1：
* ARE（top-k 估计误差）：

缓解侧：

* Reaction time（定义见上）：
* 良性吞吐下降（Throughput drop）：
* 攻击通过带宽 / 良性带宽占用（可画 CDF 或时间序列，SatShield 就用类似方式展示）。

---

## 8 你这一章“预期结论”怎么写才像论文（建议）

1. **在 LEO 场景下，控制面闭环难以及时响应**（用 tens ms vs sub-ms 的矛盾做论据）。
2. **rate-only top-k（SatShield）在 bot 规模不大时有效**，但在 bot 规模增大/速率下沉时会出现误报/漏报趋势；
3. **引入 fan-out/fan-in 与持续性**后，能在更“隐身”的 LFA（5-tuple 拆分）下保持检测优势，并且因为只对 top-k 做深统计，仍能保持资源可控（这是你“在网计算可行性”的关键卖点）。L355-L366

---

如果你愿意，我下一步可以把上面的 **MS-SatShield** 再“落到更工程化的层面”：给出 **fan-out 在数据平面可实现的两种近似结构（bitmap/HyperLogLog-like 简化版）**、对应的更新/衰减伪代码，以及把“检测→队列映射”写成一套更严格的数学阈值方案（例如用分位数估计 (\tau) 与 (\alpha,\beta) 的自适应更新规则），这样就能直接变成你论文里“算法设计+复杂度分析”的核心内容。
