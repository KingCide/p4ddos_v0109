下面我分两部分回答：先把 **SatShield 是否已经用 fan-in** 讲清楚；再给你一套“研究点 1”**可以直接照着写的章节结构**（含“构造 SatShield 会退化的卫星 LFA 设定”这一节，每一小节写什么、为什么这么写、逻辑链怎么闭合）。

------

## 1) SatShield 是否已经使用 Fan-in 维度？是否已有相关设计？

结论：**SatShield 当前方案没有把 fan-in（或 fan-out）作为检测维度/特征去设计；它是明确写在“未来工作”里的改进方向。**

- SatShield 的检测核心是 **top-k heavy flow identification**：flow key 取 **source 或 destination address**，以 **速率/字节计数**排序筛 top-k，再把 top-k 映射到队列优先级进行被动丢弃/降权。
- 在“Further Discussion / future work”里，作者明确说：未来需要 **integrating additional signatures, such as new fan-in and fan-out patterns**，来克服 **flow rate-based detection 在 bot 规模增大时的局限**。

> 很容易产生的误解：
> SatShield 评估时有一处把 flow key 改成 destination address（用于与其他方案对比），这看起来像“fan-in”（很多源打到一个目的）。
> 但严格说这仍然只是 **“按目的地址聚合的速率”**，并没有统计“有多少不同源/不同目的”（distinct count），所以不是 fan-in 签名设计。

------

## 2) 研究点 1 的章节设计（按论文顺序、逻辑闭环、每小节写什么）

我建议把研究点 1 写成一个非常“自洽”的叙事闭环：

**SatShield 的关键假设 → 我们构造卫星场景下使该假设退化的攻击设定并实证（证伪/边界） → 提出多签名（rate + fan-in/out + persist）检测 → 在网实现与复杂度 → 仿真验证与消融 → 小结。**

> 这样写的好处：你不会“凭空杜撰问题”，而是从 SatShield 自己承认的边界出发（bot 规模增大导致 rate-based detection 局限，需要 fan-in/out）。

下面是可直接作为“第 X 章 / 研究点 1”目录的版本（括号里是每节应该写的核心内容）。

------

### 第 X 章 研究点 1：面向大规模 LEO-LFA 的多签名在网检测

#### X.1 研究背景与问题陈述

写什么：

- LEO-LFA 的困难点：低速伪装、拓扑秒级变化、目标链路分布广、控制信道限制等（SatShield 引言已概括）。
- SatShield 的核心思路：利用“bot 规模受限导致攻击聚合速率高于良性”的观察，数据面 top-k 筛重流 + 队列调度缓解。
- **本章研究问题**（建议写成 1～2 句话）：
  - 当 bot 资源显著增加、攻击者能把“单聚合的速率特征”压到接近良性时，**仅靠速率的 top-k 还能可靠区分吗**？
  - 如何引入额外签名（fan-in/fan-out/持续性）保持可编程交换机上的线速可实现性？

#### X.2 系统模型与威胁模型

写什么（务必形式化，后面“构造退化设定”靠这里）：

- 时变拓扑 (G(t))，链路容量 (C_e(t))，链路利用率 (u_e(t))。
- LFA 目标：使某条（组）链路 (e^*) 满载：(\lambda_{e^*}^{benign}(t)+\lambda_{e^*}^{attack}(t)\ge C_{e^*}(t))。
- 攻击者能力边界：控制 bot 数 (B)、每 bot 总发送速率 (r)、decoy 目的集合规模 (M)、以及每 bot 如何把 (r) 分摊到 (M)（用于构造“速率退化”）。
- 防御侧可观测量：数据面能看到的 key（src/dst 或 prefix）、字节计数、队列拥塞信号等。

#### X.3 SatShield 基线回顾与可分性假设

写什么：

- SatShield 对“可分性”的关键观察：攻击流速（Mb/s 级）与良性（99% < 400Kb/s）差异显著，从而 top-k 可抓到攻击聚合。
- 基线算法机制（用 1 段话说明，不必抄细节）：top-k filter + control epoch 拉取 heavy keys + 队列优先级映射。
- **边界承认**：作者明确指出 bot 规模增大时，flow-rate based detection 有局限，需要引入 fan-in/out。

> 这一节的目标：把“为什么要做退化设定”写得顺理成章 —— 因为基线作者自己说了这里是下一步。

#### X.4 构造 “SatShield 会退化”的卫星 LFA 设定（核心亮点节）

这一节写法建议是：“提出设定 → 推导为什么会让 rate 特征重叠 → 在仿真里先验证 ‘确实重叠’（CDF/分位）→ 说明对 top-k 的影响（Precision/Recall/F1 下降）”。

**X.4.1 退化设定 A：bot 规模增大 + 每 bot 降速（Rate 可分性塌缩）**
写什么：

- 约束：为了仍然能打满链路，总攻击速率近似满足 (B\cdot r \approx C_{e^*})。
- 攻击者策略：增大 (B)，同时减小 (r)，使得**按 src 聚合的速率**从 Mb/s 降到与良性重叠区间。
- 你要给一个“可分性指标”：例如
  [
  \Delta = Q_{0.99}(R_{benign}) - Q_{0.01}(R_{attack_perkey})
  ]
  当 (\Delta < 0) 时表示“攻击每 key 速率低于良性高分位”，rate-only 很难分。
- 实验呈现：画两条 CDF（benign per-key rate vs attack per-key rate）随 (B) 增大逐渐重叠。

**X.4.2 退化设定 B：多 decoy 分摊（降低按 dst 聚合的速率，同时提高 fan-out）**
写什么：

- 攻击者把每 bot 的总速率 (r) 分摊到 (M) 个 decoy，导致某个 dst 的聚合速率近似：
  [
  R_{dst}\approx \frac{B\cdot r}{M}
  ]
  在保持 (B\cdot r) 足够打满目标链路时，增大 (M) 可以把 “按 dst 聚合的速率”压到与良性重叠。
- 同时该策略会显著提升 **fan-out**（每个 src 对应的 dst 数），这正好提供了“为什么 fan-out 是合理补充签名”的动机（与 SatShield future work 对齐）。

**X.4.3 退化设定 C：脉冲化/自适应（持续性签名的动机）**
写什么：

- SatShield 已评估动态攻击并指出 top-k 更新会带来波动（你可以用它的叙述作为“动态性存在”的依据）。
- 你构造“on-off/pulse”窗口：攻击只在部分 epoch 内出现，导致单窗阈值策略更易漏检；因此引入 “连续 (k) 窗出现” 的 persist 特征更合理。

> 这一节写完，你的改进不再是“我觉得要加 fan-in/out”，而是：
> **我构造并验证了 SatShield 的 rate-only 会退化的边界 → 因此加 fan-in/out/persist 是必要且与卫星 LFA 设定一致的。**

#### X.5 设计目标与设计原则（把“可行性”钉死）

写什么（建议列 4 条）：

- 线速可实现：只对少量候选做复杂统计，避免“记录百万流”。（SatShield也批评这类方案不适合卫星大流量环境。）
- 低误伤：优先队列降权、拥塞时被动丢弃的思想沿用 SatShield。
- 低控制开销：控制面只做 epoch 拉取与映射，不引入全局控制器（SatShield 就是这么做以降低延迟）。
- 对动态拓扑鲁棒：特征要尽量与路由变化弱耦合（fan-in/out 与“分流结构”相关，比路径本身更稳定）。

#### X.6 多签名检测方案设计（本章技术核心）

写什么（建议“候选生成→特征计算→打分→输出”四步）：

**X.6.1 候选生成：沿用 top-k heavy key（保持 SatShield 的资源优势）**

- 直接声明：我们不替换 SatShield 的 top-k filter（其资源占用很低，跟踪 top10K heavy 仅 6.11% SRAM）。
- 输出候选集合 (\mathcal{H})。

**X.6.2 特征 1：Rate（沿用）**
[
R(a)=\frac{\text{bytes}(a)}{\Delta}
]

**X.6.3 特征 2：Fan-out / Fan-in（新增，只对 (\mathcal{H}) 维护）**

- Fan-out（源地址候选）：
  [
  FO(src)=|{dst:(src,dst)\in \text{flows in }\Delta}|
  ]
- Fan-in（目的地址候选）：
  [
  FI(dst)=|{src:(src,dst)\in \text{flows in }\Delta}|
  ]
  强调：**不做全网/全流 distinct**，只对 top-k 候选维护近似 distinct（bitmap/HLL-lite/分桶计数均可，后面实现节展开）。

**X.6.4 特征 3：持续性 Persist（新增）**
[
P(a)=\sum_{i=1}^{k} \mathbf{1}[a \in \mathcal{H}_{t-i}]
]
（连续 (k) 个 epoch 中出现次数）

**X.6.5 综合评分与判决**
[
S(a)=\alpha \cdot \widetilde{R}(a)+\beta \cdot \widetilde{FO/FI}(a)+\gamma \cdot \widetilde{P}(a)
]

- (\widetilde{\cdot}) 表示归一化（可用分位数/历史均值）。
- 输出：把 (S(a)) 映射到队列优先级（与 SatShield scheduler 兼容）。

#### X.7 在网实现与复杂度分析（P4/数据面实现写法）

写什么：

- 数据面：top-k filter 그대로；新增一个“小状态区”维护候选的 FO/FI 近似计数（只对候选）。
- 控制面：epoch 拉取候选 key（SatShield 就是这个工作流）。
- 复杂度：每包额外的寄存器访问次数、哈希次数、PHV 字段占用；以及每 epoch 的拉取与映射开销（把“开销不会比 SatShield 高太多”说清楚）。

#### X.8 实验设计：先“证明退化”，再“证明改进有效”（含消融）

写什么：

- **指标**：F1/Precision/Recall（SatShield 用于 top-k 识别）、ARE（估计误差）、reaction time、throughput drop。
- **实验顺序建议**（非常关键，避免被质疑杜撰）：
  1. 复现 SatShield 在原设定下的效果（基线正确性）。
  2. 在 X.4 的退化设定 A/B/C 下，展示 SatShield 的识别指标下降（证伪边界）。
  3. 加入你的多签名后，展示指标恢复/提升（证明必要且有效）。
  4. 消融：只加 FO/FI、只加 persist、只加二者、以及参数敏感性（(\alpha,\beta,\gamma,k)）。
- **对比对象**：SatShield、ACC-Turbo、Jaqen（SatShield 本文就这么比，并解释了反应时间差异）。

#### X.9 本章小结

写什么：

- 用 4 句总结：
  1. 给出 SatShield rate-only 的适用边界；
  2. 给出退化设定下的实证结果；
  3. 多签名如何弥补退化；
  4. 对下一章（研究点 2：协同/推回/部署优化）做过渡。



# A) X.4 退化设定：实验参数表与构造方法

## A.1 总体实验框架（固定部分）

这些参数建议“对齐 SatShield 设定”，确保你不是凭空造场景，而是在它的卫星建模基础上“推进到边界条件”。

| 类别     | 参数                         | 建议取值                            | 说明                             |
| -------- | ---------------------------- | ----------------------------------- | -------------------------------- |
| 星座     | Constellation                | Starlink Shell 1, 1584 sats         | 与 SatShield一致（便于复现对比） |
| 链路     | ISL capacity                 | 20 Gbps（主），可选 10/40 Gbps      | 主结果用 20G，敏感性再扫         |
| 终端     | Uplink/Downlink              | 64/384 Mbps                         | 与 SatShield一致                 |
| 拓扑更新 | snapshot interval            | 1s（主），可选 0.5s/2s              | 影响动态性与统计窗口             |
| 背景流   | CAIDA 2019/2020 trace replay | 3/5/10/15 Gbps                      | 让“退化设定”不是只在低负载出现   |
| 目标业务 | City-pair                    | 固定 1 对（如论文例子）+ 随机 20 对 | 固定用于可复现，随机用于泛化     |

> **关键**：X.4 的任务不是“做出更强防御”，而是**证明 SatShield 的 rate-only 在某些可解释的卫星攻击设定下会退化**。所以你应先只跑 baseline（SatShield-like），画出“可分性塌缩→F1下降”的证据链。

---

## A.2 退化设定 A：bot 规模增大 + 每 bot 降速（rate 可分性塌缩）

### A.2.1 参数表（建议主表）

目标：保持“总体攻击强度足够造成目标链路拥塞”，同时让“每 key 聚合速率”进入良性区间。

定义：

* 目标链路容量：(C = 20 \text{ Gbps})
* 背景占用：(\rho \in {0.3,0.5,0.7})，则有效可用带宽约 ((1-\rho)C)
* 总攻击预算设为：(A = (1-\rho)C)（足以把链路推到满载附近）

攻击者控制：

* bot 数 (B)
* 单 bot 总发送速率 (r)
* 则总攻击速率 (B\cdot r \approx A)

| 组别 | 背景占用 (\rho) | (B)（bots） | (r)（Mbps/bot） | 总攻击 (B\cdot r) (Gbps) | 目的                              |
| ---- | --------------: | ----------: | --------------: | -----------------------: | --------------------------------- |
| A1   |             0.5 |         100 |             100 |                       10 | “少 bot 高速”应易被 rate-only抓到 |
| A2   |             0.5 |         500 |              20 |                       10 | rate 开始下沉                     |
| A3   |             0.5 |        2000 |               5 |                       10 | 接近良性大流区                    |
| A4   |             0.5 |       10000 |               1 |                       10 | “多 bot 低速”最挑战 rate-only     |

> 你也可以在 (\rho=0.3,0.7) 各复刻一遍，证明不是某个负载点的巧合。

### A.2.2 如何“让它仍然是 LFA”

你需要一个“路径/链路命中约束”，否则攻击流不一定都打到目标 ISL 上。做法有两种：

* **方法 1（推荐，贴近 SatShield）：固定目标 city-pair 的通信，攻击者选 decoy，使攻击流经由该 city-pair 的最短路/高概率路径穿过目标链路集合**（这是经典 Crossfire/LFA 构造）。
* **方法 2（仿真简化）：直接在仿真器里选择一条关键 ISL (e^*)，把 bots 的流强制路由经过 (e^*)**（用于“退化现象验证”，不用于最后结论）。

论文写法建议：主实验用方法1，方法2当 sanity check。

### A.2.3 你要产出的“证据链图”

1. **可分性塌缩图（CDF 或箱线）**

* 横轴：per-key 聚合速率（按 src 聚合或 dst 聚合，看你用哪个 key）
* 两条曲线：benign vs attack-per-key
* 随 (B) 增大，attack 曲线左移并与 benign 重叠

2. **top-k 命中质量下降图**

* 指标：Precision/Recall/F1（识别“攻击相关 key”）
* 横轴：(B) 或 (r)
* 预期：A1 高，A4 明显下降

> 注意：这里“攻击相关 key”的 ground truth 需要你定义：例如“属于 bot 集合的 src key”或“被攻击者选为 decoy 的 dst key”。

---

## A.3 退化设定 B：多 decoy 分摊（压低按 dst 聚合 rate，同时提高 fan-out）

这是最能自然引出 fan-out 的设定：攻击者把流量分散到更多目的，使得“按目的聚合的速率”不再显著，但结构性特征（每 bot 目的数）暴涨。

### A.3.1 参数表

固定 (B,r)，扫 decoy 数 (M)：

| 组别 |  (B) | (r)(Mbps) | 总攻击 (A)(Gbps) | decoy 数 (M) | 单 decoy 聚合速率 (\approx A/M) | 目的                  |
| ---- | ---: | --------: | ---------------: | -----------: | ------------------------------: | --------------------- |
| B1   | 2000 |         5 |               10 |            1 |                         10 Gbps | dst-rate 极易被抓     |
| B2   | 2000 |         5 |               10 |           10 |                          1 Gbps | 仍较明显              |
| B3   | 2000 |         5 |               10 |          100 |                        100 Mbps | 逼近“热门服务大流”    |
| B4   | 2000 |         5 |               10 |         1000 |                         10 Mbps | dst-rate 很像正常聚合 |

### A.3.2 需要同时记录 fan-out 的 ground truth

对每个 bot（src key），其 fan-out 近似为 (M)（或与 (M) 同阶）。
你在图里要展示：

* dst-rate 分布逐渐与 benign 重叠（说明 rate-only 退化）
* src 的 fan-out 分布与 benign 明显分离（说明 fan-out 有效）

### A.3.3 该设定的“卫星合理性”写法

你需要一句话把它绑定到卫星 LFA：

* LFA 的关键是“让攻击流穿过目标链路”，攻击者可以选择**多组 decoy**（多个区域/城市/服务）来确保目标链路被持续打满，同时降低每个目的聚合的可疑度。

---

## A.4 退化设定 C：Pulse / On-Off（引出 Persist）

这里不是为了 fan-in/out，而是证明“只看单窗的重流”会漏掉脉冲型策略，从而引出持续性/多窗融合。

### A.4.1 参数表（占空比 + 周期）

| 组别 |  (B) |     (r) | 周期 (T) | on 时长 (T_{on}) | 占空比 (d=T_{on}/T) |
| ---- | ---: | ------: | -------: | ---------------: | ------------------: |
| C1   |  500 | 20 Mbps |       2s |             1.5s |                0.75 |
| C2   |  500 | 20 Mbps |       2s |             0.5s |                0.25 |
| C3   |  500 | 20 Mbps |       4s |             0.5s |               0.125 |

### A.4.2 你要展示的退化现象

* 当 epoch (\Delta) 与 (T_{on}) 不对齐时，rate-only 的阈值/排名可能在部分窗口捕不到攻击 key
* Persist（连续出现次数）能稳定提升 Recall，并降低“top-k振荡导致的误判波动”

---

# B) X.6 FO/FI 近似实现：两套可落地方案（Bitmap 与 HLL-lite）

核心原则：**只对 top-k 候选 key 维护 FO/FI**。
理由：全量 distinct 统计会爆状态，违背 SatShield 的“只盯最关键小集合”的工程哲学。

下面给你一套“候选集维护方法”，再分别给 bitmap 与 HLL-lite。

---

## B.0 候选集 (\mathcal{H}) 的维护方式（两种）

### 方案 0-1：epoch 末从 top-k 结构导出（最贴近 SatShield）

* 每个 epoch 结束，agent 读出 top-k heavy keys（如 SatShield 的做法），得到 (\mathcal{H})
* 下一 epoch 内，对属于 (\mathcal{H}) 的 key 才维护 FO/FI 结构
  优点：实现简单、状态上限固定；缺点：对“突然出现的新 key”有 1 个 epoch 延迟。

### 方案 0-2：在线候选（更快，但更复杂）

* 当某 key 在 top-k filter 中晋升或计数超过预阈值时，立刻加入候选
* 维护一个小型候选表（例如最多 K=10K）
  优点：更快；缺点：P4逻辑更复杂，建议作为拓展实验。

> 论文主线建议用 0-1，稳、好写、可复现。

---

## B.1 方案一：Bitmap（最简单、P4 最容易落地）

### B.1.1 目标：估计 (FO(src)) 或 (FI(dst))

对候选 key (a)，要估计集合大小 (|{x}|)（例如 dst 集合或 src 集合）。

### B.1.2 数据结构

* 对每个候选 key (a)，分配一个长度为 (m) 的 bitset（位图）
* 每来一包属于关系对 ((a,x))（例如 (a=src, x=dst)），计算：
  [
  i = h(x) \bmod m
  ]
  设置 bitmap[a][i] = 1

> **内存预算**：
> 若候选数为 (K)，每个位图 (m) bits，则总内存 (K\cdot m) bits。
> 举例：K=10k，m=128 bits → 1.28 Mbits ≈ 160 KB（很小）；m=256 bits → 320 KB。

### B.1.3 估计公式

位图中 0 的比例可估计基数（线性计数 Linear Counting）：
[
\widehat{n} = -m \cdot \ln\left(\frac{Z}{m}\right)
]
其中 (Z) 是 bitset 中 0 的个数。

### B.1.4 误差与适用范围

* 当真实基数 (n) 明显小于 (m) 时效果好；当 (n) 接近/超过 (m) 时饱和，误差变大
* 对你这个场景很合理：你不是要精确算 10 万目的数，而是要区分“正常（小 fan-out）”与“攻击（很大 fan-out）”，阈值型判别即可。

### B.1.5 P4 落地要点

* **写位图**：P4 可用寄存器数组模拟 bitset（每个 key 对应若干个 32-bit/64-bit word）
* **计算 (\widehat{n})**：数据面不做 ln；做法是：

  * 数据面只更新位图；
  * **控制面/agent 在 epoch 末读取位图，计算 (\widehat{n})**（数学运算放控制面，符合 SatShield 也把复杂排序放控制面的思路）
* **清理策略**：每个 epoch 清零位图（或用双缓冲：bitmap_even/bitmap_odd 隔窗交替），避免“reset 被攻击对齐”的问题时可改用衰减（但衰减在 bitmap 上实现会麻烦，优先双缓冲）。

### B.1.6 何时选 bitmap？

* 你论文希望 **实现简单、状态可控、易复现**
* 你的 FO/FI 只用来判别“大 vs 小”，不是追求高精度

---

## B.2 方案二：HLL-lite（更稳健、抗饱和，代价略高）

HyperLogLog 的优势是：在较小内存下可估计更大范围的基数，且相对误差可控。

### B.2.1 数据结构

对候选 key (a) 分配 (m=2^p) 个寄存器（每个寄存器存一个小整数，典型 5~6 bits 足够）。

更新时：

1. 计算 32-bit hash：
   [
   y = h(x)
   ]
2. 取低 (p) 位作为寄存器索引：
   [
   j = y \ &\ (m-1)
   ]
3. 用剩余位计算前导零数（rank）：
   [
   \rho = 1 + \text{clz}(y \gg p)
   ]
4. 更新寄存器：
   [
   M_a[j] = \max(M_a[j], \rho)
   ]

### B.2.2 估计公式（控制面计算）

[
\widehat{n} = \alpha_m \cdot m^2 \cdot \left(\sum_{j=1}^{m} 2^{-M_a[j]}\right)^{-1}
]
其中 (\alpha_m) 是常数（例如 m=16/32/64/128 有对应经验值）。

> 同样建议：P4 数据面只做寄存器 max 更新；估计计算在 agent/控制面做。

### B.2.3 内存与误差

* HLL 的相对标准误差约：
  [
  \text{RSE} \approx \frac{1.04}{\sqrt{m}}
  ]
  例如 m=64 → RSE≈13%；m=256 → RSE≈6.5%
* 内存：若每寄存器 6 bits、m=64，则每 key 384 bits=48B；K=10k 时约 480KB（仍可接受）

### B.2.4 P4 落地要点（关键是 clz）

* P4/Tofino 对一些位运算支持有限，**clz 可能没有原语**：

  * 工程做法：用**查表近似**（例如对高位字节做 leading-zero lookup），或用“找最高位1的位置”表实现 rank；
  * 或者采用简化的“LogLog-lite”：只用 hash 的前 8/16 位查表估 rank（精度略降但足够用于阈值判别）。
* 寄存器更新是 `max`，P4 很容易做。

### B.2.5 何时选 HLL-lite？

* 你希望 **支持更大 fan-out/fan-in 范围**，避免 bitmap 饱和导致“很多攻击都看起来一样大”
* 你想做“参数敏感性”展示：m 增大误差下降（论文表达更有说服力）

---

# C) 如何把这两套 FO/FI 方案写进你的“实验矩阵”（建议）

你可以把 FO/FI 估计结构作为一个“实现维度”写进消融与敏感性：

| 实验组 | 候选来源 | FO/FI 结构                | 每 key 内存 | 预期现象                         |
| ------ | -------- | ------------------------- | ----------: | -------------------------------- |
| S0     | top-k    | 无（SatShield rate-only） |           0 | 在退化设定 A/B 下 F1下降         |
| S1     | top-k    | bitmap m=128              |         16B | 在 B（多decoy）下 Recall显著回升 |
| S2     | top-k    | bitmap m=256              |         32B | 饱和更少，误判更低               |
| S3     | top-k    | HLL-lite m=64,6bits       |         48B | 大 fan-out 仍能区分，稳健        |
| S4     | top-k    | HLL-lite m=256,6bits      |        192B | 精度最好，资源最高               |

然后你在 X.4 的退化设定里，至少要证明两件事：

1. **rate-only 在 A/B 确实退化**（先证伪基线）
2. **引入 FO/FI 后在 B（多 decoy）明显恢复**（再证明新签名确有价值）

---

# D) 你写论文时最容易被问到的 3 个“必须预先回答”的点

1. **Ground truth 怎么定义？**

* 对于 FO(src)：攻击 bot 集合的 src key 应该有更高 FO；
* 对于 FI(dst)：攻击 decoy 目的集合的 dst key 应该有更高 FI；
  你要在仿真生成器里保留“哪些 bot、哪些 decoy、哪些链路是目标”的标签。

2. **为什么只对 top-k 候选做 FO/FI？会不会漏？**
   答法：你把 top-k 当作“候选生成器”，FO/FI 是二次判别，资源可控；漏检风险通过选择较大的 K、较短 epoch 或在线晋升机制缓解（可作为拓展实验）。

3. **FO/FI 在卫星动态拓扑下是否稳定？**
   答法：FO/FI 是“流量结构性特征”，跟路由具体怎么变弱耦合；你会在“快照间隔/epoch”敏感性实验里验证它的稳定性。

---

如果你接下来要继续推进，我建议你告诉我两件你倾向的设计选择（不用很精确）：

* 你想把候选数 (K) 设为 1k/5k/10k 的哪个量级？
* 你更倾向 bitmap（简单）还是 HLL-lite（稳健）作为主线？

即使你不回答，我也可以默认：主线用 **bitmap m=256 + K=10k + 双缓冲**，拓展实验再加 HLL-lite 做对比。
